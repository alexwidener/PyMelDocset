<html><body><p>﻿<!-- saved from url=(0024)http://docs.autodesk.com -->
<!DOCTYPE html>

<!-- Mirrored from help.autodesk.com/cloudhelp/2016/ENU/Maya-Tech-Docs/PyMel/generated/classes/pymel.util.common/pymel.util.common.path.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 05:16:32 GMT -->
<!-- Added by HTTrack --><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->
</p>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>pymel.util.common.path — PyMEL 1.0.7 documentation</title>
<link href="../../../_static/nature.css" rel="stylesheet" type="text/css"/>
<link href="../../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
<script src="../../../_static/jquery.js" type="text/javascript"></script>
<script src="../../../_static/underscore.js" type="text/javascript"></script>
<script src="../../../_static/doctools.js" type="text/javascript"></script>
<link href="../../../index-2.html" rel="top" title="PyMEL 1.0.7 documentation"/>
<link href="../../pymel.util.common.html" rel="up" title="pymel.util.common"/>
<link href="../../pymel.util.decoration.html" rel="next" title="pymel.util.decoration"/>
<link href="../../functions/pymel.util.common/pymel.util.common.unescape.html" rel="prev" title="pymel.util.common.unescape"/>
<link href="../../../../style/adsk.cpm.css" rel="stylesheet" type="text/css"/><meta content="expert" name="experiencelevel"/><meta content="programmer" name="audience"/><meta content="enable" name="user-comments"/><meta content="ENU" name="language"/><meta content="MAYAUL" name="product"/><meta content="2016" name="release"/><meta content="Customization" name="book"/><meta content="Maya-Tech-Docs" name="component"/><meta content="/view/MAYAUL/2016/ENU/" name="helpsystempath"/><meta content="04/03/2015" name="created"/><meta content="04/03/2015" name="modified"/><meta content="Navigation 
 
 
 index 
 
 modules | 
 
 next | 
 
 previous | 
 PyMEL 1.0.7 documentation » 
 pymel.util.common » 
 
 

 
 
 
 
 
 
 pymel.util.common.path ¶ 
 
 
 
 
 
 
 
 
 class path ( other='' ) ¶ 
 Represents a filesystem path. 
 For documentation on individual methods, consult their
counterparts in os.path. 
 
 
 abspath ( ) ¶ 
 
 See also 
 os.path.abspath() 
 
 

 
 
 access ( mode ) ¶ 
 Return true if current user has access to this path. 
 mode - One of the constants..." name="description"/><meta content="__PyMel_generated_classes_pymel_util_common_pymel_util_common_path_html" name="topicid"/>
<div class="related">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a accesskey="I" href="../../../genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="../../../py-modindex.html" title="Python Module Index">modules</a> |</li>
<li class="right">
<a accesskey="N" href="../../pymel.util.decoration.html" title="pymel.util.decoration">next</a> |</li>
<li class="right">
<a accesskey="P" href="../../functions/pymel.util.common/pymel.util.common.unescape.html" title="pymel.util.common.unescape">previous</a> |</li>
<li><a href="../../../index-2.html">PyMEL 1.0.7 documentation</a> »</li>
<li><a accesskey="U" href="../../pymel.util.common.html">pymel.util.common</a> »</li>
</ul>
</div>
<div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body">
<div class="section" id="pymel-util-common-path">
<h1>pymel.util.common.path<a class="headerlink" href="#pymel-util-common-path" title="Permalink to this headline">¶</a></h1>
<p class="graphviz">
<img alt="Inheritance diagram of path" class="inheritance" src="../../../_images/inheritance-da0429b496b1cb5a5b5763c9d432cda058d27605.png" usemap="#inheritancea12a28fac9"/>
<map id="inheritancea12a28fac9" name="inheritancea12a28fac9">
<area alt="" coords="5,5,77,29" id="node1" shape="rect" title="Represents a filesystem path."></area>
</map>
</p>
<dl class="class">
<dt id="pymel.util.common.path"><a name="//apple_ref/cpp/Class/pymel.util.common.path"></a>
<em class="property">class </em><tt class="descname">path</tt><big>(</big><em>other=''</em><big>)</big><a class="headerlink" href="#pymel.util.common.path" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a filesystem path.</p>
<p>For documentation on individual methods, consult their
counterparts in os.path.</p>
<dl class="method">
<dt id="pymel.util.common.path.abspath">
<tt class="descname">abspath</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.abspath" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.abspath()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.access">
<tt class="descname">access</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.access" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if current user has access to this path.</p>
<p>mode - One of the constants <tt class="xref py py-data docutils literal"><span class="pre">os.F_OK</span></tt>, <tt class="xref py py-data docutils literal"><span class="pre">os.R_OK</span></tt>,
<tt class="xref py py-data docutils literal"><span class="pre">os.W_OK</span></tt>, <tt class="xref py py-data docutils literal"><span class="pre">os.X_OK</span></tt></p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.access()</span></tt></p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.atime">
<tt class="descname">atime</tt><a class="headerlink" href="#pymel.util.common.path.atime" title="Permalink to this definition">¶</a></dt>
<dd><p>Last access time of the file.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.getatime" title="pymel.util.common.path.getatime"><tt class="xref py py-meth docutils literal"><span class="pre">getatime()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.path.getatime()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.basename">
<tt class="descname">basename</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.basename" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.name" title="pymel.util.common.path.name"><tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.path.basename()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.bytes">
<tt class="descname">bytes</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file, read all bytes, return them as a string.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.canonicalpath">
<tt class="descname">canonicalpath</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.canonicalpath" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to return a ‘canonical’ version of the path</p>
<p>This will standardize for symbolic links, absolute/relative paths,
case differences (if on a case-insensitive file system), and ‘..’
usage (so paths such as A//B, A/./B and A/foo/../B will all compare equal).</p>
<p>The intention is that string comparison of canonical paths will yield
a reasonable guess as to whether two paths represent the same file.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.cd">
<tt class="descname">cd</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.cd" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.chdir()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.chdir">
<tt class="descname">chdir</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.chdir" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.chdir()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.chgrp">
<tt class="descname">chgrp</tt><big>(</big><em>group</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.chgrp" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility for setting the group permissions of a file or folder.
<tt class="xref py py-obj docutils literal"><span class="pre">group</span></tt> can be the name as a string or an integer id.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.chown()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.chmod">
<tt class="descname">chmod</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.chmod" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.chmod()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.chown">
<tt class="descname">chown</tt><big>(</big><em>uid=-1</em>, <em>gid=-1</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.chown" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.chown()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.chroot">
<tt class="descname">chroot</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.chroot" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.chroot()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.chunks">
<tt class="descname">chunks</tt><big>(</big><em>size</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.chunks" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns a generator yielding chunks of the file, so it can</dt>
<dd>be read piece by piece with a simple for loop.</dd>
</dl>
<p>Any argument you pass after <a class="reference internal" href="#pymel.util.common.path.size" title="pymel.util.common.path.size"><tt class="xref py py-obj docutils literal"><span class="pre">size</span></tt></a> will be passed to <a class="reference internal" href="#pymel.util.common.path.open" title="pymel.util.common.path.open"><tt class="xref py py-obj docutils literal"><span class="pre">open()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"><blockquote class="first">
<div><p>&gt;&gt; for chunk in path(“file.txt”).chunks(8192):
..    print(chunk)</p>
</div></blockquote>
<p class="last">This will read the file by chunks of 8192 bytes.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.copy">
<tt class="descname">copy</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy data and mode bits (“cp src dst”).</p>
<p>The destination may be a directory.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.copy2">
<tt class="descname">copy2</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.copy2" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy data and all stat info (“cp -p src dst”).</p>
<p>The destination may be a directory.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.copyfile">
<tt class="descname">copyfile</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.copyfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy data from src to dst</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.copymode">
<tt class="descname">copymode</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.copymode" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy mode bits from src to dst</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.copystat">
<tt class="descname">copystat</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.copystat" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy all stat info (mode bits, atime, mtime, flags) from src to dst</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.copytree">
<tt class="descname">copytree</tt><big>(</big><em>src</em>, <em>dst</em>, <em>symlinks=False</em>, <em>ignore=None</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.copytree" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively copy a directory tree using copy2().</p>
<p>The destination directory must not already exist.
If exception(s) occur, an Error is raised with a list of reasons.</p>
<p>If the optional symlinks flag is true, symbolic links in the
source tree result in symbolic links in the destination tree; if
it is false, the contents of the files pointed to by symbolic
links are copied.</p>
<p>The optional ignore argument is a callable. If given, it
is called with the <tt class="xref py py-obj docutils literal"><span class="pre">src</span></tt> parameter, which is the directory
being visited by copytree(), and <tt class="xref py py-obj docutils literal"><span class="pre">names</span></tt> which is the list of
<tt class="xref py py-obj docutils literal"><span class="pre">src</span></tt> contents, as returned by os.listdir():</p>
<blockquote>
<div>callable(src, names) -&gt; ignored_names</div></blockquote>
<p>Since copytree() is called recursively, the callable will be
called once for each directory that is copied. It returns a
list of names relative to the <tt class="xref py py-obj docutils literal"><span class="pre">src</span></tt> directory that should
not be copied.</p>
<p>XXX Consider this example code rather than the ultimate tool.</p>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.ctime">
<tt class="descname">ctime</tt><a class="headerlink" href="#pymel.util.common.path.ctime" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation time of the file.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.getctime" title="pymel.util.common.path.getctime"><tt class="xref py py-meth docutils literal"><span class="pre">getctime()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.path.getctime()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.dirname">
<tt class="descname">dirname</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.dirname" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.parent" title="pymel.util.common.path.parent"><tt class="xref py py-attr docutils literal"><span class="pre">parent</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.path.dirname()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.dirs">
<tt class="descname">dirs</tt><big>(</big><big>)</big> → List of this directory's subdirectories.<a class="headerlink" href="#pymel.util.common.path.dirs" title="Permalink to this definition">¶</a></dt>
<dd><p>The elements of the list are path objects.
This does not walk recursively into subdirectories
(but see <a class="reference internal" href="#pymel.util.common.path.walkdirs" title="pymel.util.common.path.walkdirs"><tt class="xref py py-meth docutils literal"><span class="pre">walkdirs()</span></tt></a>).</p>
<p>With the optional <tt class="xref py py-obj docutils literal"><span class="pre">pattern</span></tt> argument, this only lists
directories whose names match the given pattern.  For
example, <tt class="docutils literal"><span class="pre">d.dirs('build-*')</span></tt>.</p>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.drive">
<tt class="descname">drive</tt><a class="headerlink" href="#pymel.util.common.path.drive" title="Permalink to this definition">¶</a></dt>
<dd><p>The drive specifier, for example <tt class="docutils literal"><span class="pre">'C:'</span></tt>.</p>
<p>This is always empty on systems that don’t use drive specifiers.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.exists">
<tt class="descname">exists</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.exists" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.exists()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.expand">
<tt class="descname">expand</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up a filename by calling <a class="reference internal" href="#pymel.util.common.path.expandvars" title="pymel.util.common.path.expandvars"><tt class="xref py py-meth docutils literal"><span class="pre">expandvars()</span></tt></a>,
<a class="reference internal" href="#pymel.util.common.path.expanduser" title="pymel.util.common.path.expanduser"><tt class="xref py py-meth docutils literal"><span class="pre">expanduser()</span></tt></a>, and <a class="reference internal" href="#pymel.util.common.path.normpath" title="pymel.util.common.path.normpath"><tt class="xref py py-meth docutils literal"><span class="pre">normpath()</span></tt></a> on it.</p>
<p>This is commonly everything needed to clean up a filename
read from a configuration file, for example.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.expanduser">
<tt class="descname">expanduser</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.expanduser" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.expanduser()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.expandvars">
<tt class="descname">expandvars</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.expandvars" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.expandvars()</span></tt></p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.ext">
<tt class="descname">ext</tt><a class="headerlink" href="#pymel.util.common.path.ext" title="Permalink to this definition">¶</a></dt>
<dd><p>The file extension, for example <tt class="docutils literal"><span class="pre">'.py'</span></tt>.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.files">
<tt class="descname">files</tt><big>(</big><big>)</big> → List of the files in this directory.<a class="headerlink" href="#pymel.util.common.path.files" title="Permalink to this definition">¶</a></dt>
<dd><p>The elements of the list are path objects.
This does not walk into subdirectories (see <a class="reference internal" href="#pymel.util.common.path.walkfiles" title="pymel.util.common.path.walkfiles"><tt class="xref py py-meth docutils literal"><span class="pre">walkfiles()</span></tt></a>).</p>
<p>With the optional <tt class="xref py py-obj docutils literal"><span class="pre">pattern</span></tt> argument, this only lists files
whose names match the given pattern.  For example,
<tt class="docutils literal"><span class="pre">d.files('*.pyc')</span></tt>.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.fnmatch">
<tt class="descname">fnmatch</tt><big>(</big><em>pattern</em>, <em>normcase=None</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.fnmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="xref py py-obj docutils literal"><span class="pre">self.name</span></tt> matches the given pattern.</p>
<dl class="docutils">
<dt>pattern - A filename pattern with wildcards,</dt>
<dd>for example <tt class="docutils literal"><span class="pre">'*.py'</span></tt>. If the pattern contains a <a class="reference internal" href="#pymel.util.common.path.normcase" title="pymel.util.common.path.normcase"><tt class="xref py py-obj docutils literal"><span class="pre">normcase</span></tt></a>
attribute, it is applied to the name and path prior to comparison.</dd>
<dt>normcase - (optional) A function used to normalize the pattern and</dt>
<dd>filename before matching. Defaults to self.module which defaults
to os.path.normcase.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">fnmatch.fnmatch()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.get_groupname">
<tt class="descname">get_groupname</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.get_groupname" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the group name for this file or directory.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.chgrp" title="pymel.util.common.path.chgrp"><tt class="xref py py-meth docutils literal"><span class="pre">chgrp()</span></tt></a></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.get_owner">
<tt class="descname">get_owner</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.get_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the owner of this file or directory. Follow
symbolic links.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.owner" title="pymel.util.common.path.owner"><tt class="xref py py-attr docutils literal"><span class="pre">owner</span></tt></a></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.getatime">
<tt class="descname">getatime</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.getatime" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.atime" title="pymel.util.common.path.atime"><tt class="xref py py-attr docutils literal"><span class="pre">atime</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.path.getatime()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.getctime">
<tt class="descname">getctime</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.getctime" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.ctime" title="pymel.util.common.path.ctime"><tt class="xref py py-attr docutils literal"><span class="pre">ctime</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.path.getctime()</span></tt></p>
</div>
</dd></dl>
<dl class="classmethod">
<dt id="pymel.util.common.path.getcwd">
<em class="property">classmethod </em><tt class="descname">getcwd</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.getcwd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current working directory as a path object.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.getcwdu()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.getmtime">
<tt class="descname">getmtime</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.getmtime" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.mtime" title="pymel.util.common.path.mtime"><tt class="xref py py-attr docutils literal"><span class="pre">mtime</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.path.getmtime()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.getsize">
<tt class="descname">getsize</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.getsize" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.size" title="pymel.util.common.path.size"><tt class="xref py py-attr docutils literal"><span class="pre">size</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.path.getsize()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.glob">
<tt class="descname">glob</tt><big>(</big><em>pattern</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.glob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of path objects that match the pattern.</p>
<p><tt class="xref py py-obj docutils literal"><span class="pre">pattern</span></tt> - a path relative to this directory, with wildcards.</p>
<p>For example, <tt class="docutils literal"><span class="pre">path('/users').glob('*/bin/*')</span></tt> returns a list
of all the files users have in their bin directories.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">glob.glob()</span></tt></p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.groupname">
<tt class="descname">groupname</tt><a class="headerlink" href="#pymel.util.common.path.groupname" title="Permalink to this definition">¶</a></dt>
<dd><p>The group name for this file or directory.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.get_groupname" title="pymel.util.common.path.get_groupname"><tt class="xref py py-meth docutils literal"><span class="pre">get_groupname()</span></tt></a></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.isabs">
<tt class="descname">isabs</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.isabs" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.isabs()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.isdir">
<tt class="descname">isdir</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.isdir" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.isdir()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.isfile">
<tt class="descname">isfile</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.isfile" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.isfile()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.islink">
<tt class="descname">islink</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.islink" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.islink()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.ismount">
<tt class="descname">ismount</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.ismount" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.ismount()</span></tt></p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.joinpath">
<tt class="descname">joinpath</tt><em class="property"> = &lt;functools.partial object at 0x1463326d8&gt;</em><a class="headerlink" href="#pymel.util.common.path.joinpath" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.lines">
<tt class="descname">lines</tt><big>(</big><em>encoding=None</em>, <em>errors='strict'</em>, <em>retain=True</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file, read all lines, return them in a list.</p>
<dl class="docutils">
<dt>Optional arguments:</dt>
<dd><dl class="first last docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">encoding</span></tt> - The Unicode encoding (or character set) of</dt>
<dd>the file.  The default is None, meaning the content
of the file is read as 8-bit characters and returned
as a list of (non-Unicode) str objects.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">errors</span></tt> - How to handle Unicode errors; see help(str.decode)</dt>
<dd>for the options.  Default is ‘strict’</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">retain</span></tt> - If true, retain newline characters; but all newline</dt>
<dd>character combinations (<tt class="docutils literal"><span class="pre">'\r'</span></tt>, <tt class="docutils literal"><span class="pre">'\n'</span></tt>, <tt class="docutils literal"><span class="pre">'\r\n'</span></tt>) are
translated to <tt class="docutils literal"><span class="pre">'\n'</span></tt>.  If false, newline characters are
stripped off.  Default is True.</dd>
</dl>
</dd>
</dl>
<p>This uses <tt class="docutils literal"><span class="pre">'U'</span></tt> mode.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.text" title="pymel.util.common.path.text"><tt class="xref py py-meth docutils literal"><span class="pre">text()</span></tt></a></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.link">
<tt class="descname">link</tt><big>(</big><em>newpath</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.link" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a hard link at <tt class="xref py py-obj docutils literal"><span class="pre">newpath</span></tt>, pointing to this file.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.link()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.listdir">
<tt class="descname">listdir</tt><big>(</big><big>)</big> → List of items in this directory.<a class="headerlink" href="#pymel.util.common.path.listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Use <a class="reference internal" href="#pymel.util.common.path.files" title="pymel.util.common.path.files"><tt class="xref py py-meth docutils literal"><span class="pre">files()</span></tt></a> or <a class="reference internal" href="#pymel.util.common.path.dirs" title="pymel.util.common.path.dirs"><tt class="xref py py-meth docutils literal"><span class="pre">dirs()</span></tt></a> instead if you want a listing
of just files or just subdirectories.</p>
<p>The elements of the list are path objects.</p>
<p>With the optional <tt class="xref py py-obj docutils literal"><span class="pre">pattern</span></tt> argument, this only lists
items whose names match the given pattern. Pattern may be a glob-style
string or a compiled regular expression pattern.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.files" title="pymel.util.common.path.files"><tt class="xref py py-meth docutils literal"><span class="pre">files()</span></tt></a>, <a class="reference internal" href="#pymel.util.common.path.dirs" title="pymel.util.common.path.dirs"><tt class="xref py py-meth docutils literal"><span class="pre">dirs()</span></tt></a>, <a class="reference internal" href="#pymel.util.common.path.match" title="pymel.util.common.path.match"><tt class="xref py py-meth docutils literal"><span class="pre">match()</span></tt></a></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.lstat">
<tt class="descname">lstat</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.lstat" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#pymel.util.common.path.stat" title="pymel.util.common.path.stat"><tt class="xref py py-meth docutils literal"><span class="pre">stat()</span></tt></a>, but do not follow symbolic links.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.stat" title="pymel.util.common.path.stat"><tt class="xref py py-meth docutils literal"><span class="pre">stat()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.lstat()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.makedirs">
<tt class="descname">makedirs</tt><big>(</big><em>mode=511</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.makedirs" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.makedirs()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.makedirs_p">
<tt class="descname">makedirs_p</tt><big>(</big><em>mode=511</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.makedirs_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#pymel.util.common.path.makedirs" title="pymel.util.common.path.makedirs"><tt class="xref py py-meth docutils literal"><span class="pre">makedirs()</span></tt></a>, but does not raise an exception if the
directory already exists.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.match">
<tt class="descname">match</tt><big>(</big><em>pattern</em>, <em>normcase=None</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="xref py py-obj docutils literal"><span class="pre">self.name</span></tt> matches the given pattern. Supports
both glob strings and compiled regular expressions.</p>
<dl class="docutils">
<dt>pattern - A glob-style filename pattern with wildcards, or regex pattern</dt>
<dd>compiled with <tt class="xref py py-func docutils literal"><span class="pre">re.compile()</span></tt>.
If the pattern contains a <a class="reference internal" href="#pymel.util.common.path.normcase" title="pymel.util.common.path.normcase"><tt class="xref py py-obj docutils literal"><span class="pre">normcase</span></tt></a>  attribute, it is applied to
the name and path prior to comparison.</dd>
<dt>normcase - (optional) A function used to normalize the pattern and</dt>
<dd>filename before matching. Defaults to self.module which defaults
to os.path.normcase.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.fnmatch" title="pymel.util.common.path.fnmatch"><tt class="xref py py-meth docutils literal"><span class="pre">fnmatch()</span></tt></a> and <a class="reference internal" href="#pymel.util.common.path.regmatch" title="pymel.util.common.path.regmatch"><tt class="xref py py-meth docutils literal"><span class="pre">regmatch()</span></tt></a></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.mkdir">
<tt class="descname">mkdir</tt><big>(</big><em>mode=511</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.mkdir" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.mkdir()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.mkdir_p">
<tt class="descname">mkdir_p</tt><big>(</big><em>mode=511</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.mkdir_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#pymel.util.common.path.mkdir" title="pymel.util.common.path.mkdir"><tt class="xref py py-meth docutils literal"><span class="pre">mkdir()</span></tt></a>, but does not raise an exception if the
directory already exists.</p>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.module">
<tt class="descname">module</tt><em class="property"> = &lt;module 'posixpath' from '/Applications/Autodesk/maya2016/Maya.app/Contents/Frameworks/Python.framework/Versions/Current/lib/python2.7/posixpath.pyc'&gt;</em><a class="headerlink" href="#pymel.util.common.path.module" title="Permalink to this definition">¶</a></dt>
<dd><p>The path module to use for path operations.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-mod docutils literal"><span class="pre">os.path</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.move">
<tt class="descname">move</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively move a file or directory to another location. This is
similar to the Unix “mv” command.</p>
<p>If the destination is a directory or a symlink to a directory, the source
is moved inside the directory. The destination path must not already
exist.</p>
<p>If the destination already exists but is not a directory, it may be
overwritten depending on os.rename() semantics.</p>
<p>If the destination is on our current filesystem, then rename() is used.
Otherwise, src is copied to the destination and then removed.
A lot more could be done here...  A look at a mv.c shows a lot of
the issues this implementation glosses over.</p>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.mtime">
<tt class="descname">mtime</tt><a class="headerlink" href="#pymel.util.common.path.mtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Last-modified time of the file.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.getmtime" title="pymel.util.common.path.getmtime"><tt class="xref py py-meth docutils literal"><span class="pre">getmtime()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.path.getmtime()</span></tt></p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.name">
<tt class="descname">name</tt><a class="headerlink" href="#pymel.util.common.path.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of this file or directory without the full path.</p>
<p>For example,
<tt class="docutils literal"><span class="pre">path('/usr/local/lib/libpython.so').name</span> <span class="pre">==</span> <span class="pre">'libpython.so'</span></tt></p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.basename" title="pymel.util.common.path.basename"><tt class="xref py py-meth docutils literal"><span class="pre">basename()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.path.basename()</span></tt></p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.namebase">
<tt class="descname">namebase</tt><a class="headerlink" href="#pymel.util.common.path.namebase" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as <a class="reference internal" href="#pymel.util.common.path.name" title="pymel.util.common.path.name"><tt class="xref py py-meth docutils literal"><span class="pre">name()</span></tt></a>, but with one file extension stripped off.</p>
<p>For example,
<tt class="docutils literal"><span class="pre">path('/home/guido/python.tar.gz').name</span> <span class="pre">==</span> <span class="pre">'python.tar.gz'</span></tt>,
but
<tt class="docutils literal"><span class="pre">path('/home/guido/python.tar.gz').namebase</span> <span class="pre">==</span> <span class="pre">'python.tar'</span></tt>.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.normcase">
<tt class="descname">normcase</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.normcase" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.normcase()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.normpath">
<tt class="descname">normpath</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.normpath" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.normpath()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.open">
<tt class="descname">open</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file.  Return a file object.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">python:open()</span></tt></p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.owner">
<tt class="descname">owner</tt><a class="headerlink" href="#pymel.util.common.path.owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the owner of this file or directory.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.get_owner" title="pymel.util.common.path.get_owner"><tt class="xref py py-meth docutils literal"><span class="pre">get_owner()</span></tt></a></p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.parent">
<tt class="descname">parent</tt><a class="headerlink" href="#pymel.util.common.path.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>This path’s parent directory, as a new path object.</p>
<p>For example,
<tt class="docutils literal"><span class="pre">path('/usr/local/lib/libpython.so').parent</span> <span class="pre">==</span>
<span class="pre">path('/usr/local/lib')</span></tt></p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.dirname" title="pymel.util.common.path.dirname"><tt class="xref py py-meth docutils literal"><span class="pre">dirname()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.path.dirname()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.pathconf">
<tt class="descname">pathconf</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.pathconf" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.pathconf()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.read_hash">
<tt class="descname">read_hash</tt><big>(</big><em>hash_name</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.read_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate given hash for this file.</p>
<p>List of supported hashes can be obtained from <tt class="xref py py-mod docutils literal"><span class="pre">hashlib</span></tt> package.
This reads the entire file.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-meth docutils literal"><span class="pre">hashlib.hash.digest()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.read_hexhash">
<tt class="descname">read_hexhash</tt><big>(</big><em>hash_name</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.read_hexhash" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate given hash for this file, returning hexdigest.</p>
<p>List of supported hashes can be obtained from <tt class="xref py py-mod docutils literal"><span class="pre">hashlib</span></tt> package.
This reads the entire file.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-meth docutils literal"><span class="pre">hashlib.hash.hexdigest()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.read_md5">
<tt class="descname">read_md5</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.read_md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the md5 hash for this file.</p>
<p>This reads through the entire file.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.read_hash" title="pymel.util.common.path.read_hash"><tt class="xref py py-meth docutils literal"><span class="pre">read_hash()</span></tt></a></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.readlink">
<tt class="descname">readlink</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.readlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to which this symbolic link points.</p>
<p>The result may be an absolute or a relative path.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.readlinkabs" title="pymel.util.common.path.readlinkabs"><tt class="xref py py-meth docutils literal"><span class="pre">readlinkabs()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.readlink()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.readlinkabs">
<tt class="descname">readlinkabs</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.readlinkabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to which this symbolic link points.</p>
<p>The result is always an absolute path.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.readlink" title="pymel.util.common.path.readlink"><tt class="xref py py-meth docutils literal"><span class="pre">readlink()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.readlink()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.realpath">
<tt class="descname">realpath</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.realpath" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.realpath()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.regmatch">
<tt class="descname">regmatch</tt><big>(</big><em>pattern</em>, <em>normcase=None</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.regmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="xref py py-obj docutils literal"><span class="pre">self.name</span></tt> matches the given pattern.</p>
<dl class="docutils">
<dt>pattern - A regex pattern compiled with <tt class="xref py py-func docutils literal"><span class="pre">re.compile()</span></tt>.</dt>
<dd>If the pattern contains a <a class="reference internal" href="#pymel.util.common.path.normcase" title="pymel.util.common.path.normcase"><tt class="xref py py-obj docutils literal"><span class="pre">normcase</span></tt></a>  attribute, it is applied to
the name and path prior to comparison.</dd>
<dt>normcase - (optional) A function used to normalize the</dt>
<dd>filename before matching. Defaults to self.module which defaults
to os.path.normcase.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a href="#id1"><span class="problematic" id="id2">:module:`re`</span></a></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.relpath">
<tt class="descname">relpath</tt><big>(</big><em>start='.'</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.relpath" title="Permalink to this definition">¶</a></dt>
<dd><p>Return this path as a relative path,
based from <tt class="xref py py-obj docutils literal"><span class="pre">start</span></tt>, which defaults to the current working directory.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.relpathto">
<tt class="descname">relpathto</tt><big>(</big><em>dest</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.relpathto" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a relative path from <tt class="xref py py-obj docutils literal"><span class="pre">self</span></tt> to <tt class="xref py py-obj docutils literal"><span class="pre">dest</span></tt>.</p>
<p>If there is no relative path from <tt class="xref py py-obj docutils literal"><span class="pre">self</span></tt> to <tt class="xref py py-obj docutils literal"><span class="pre">dest</span></tt>, for example if
they reside on different drives in Windows, then this returns
<tt class="docutils literal"><span class="pre">dest.abspath()</span></tt>.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.remove">
<tt class="descname">remove</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.remove" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.remove()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.remove_p">
<tt class="descname">remove_p</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.remove_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#pymel.util.common.path.remove" title="pymel.util.common.path.remove"><tt class="xref py py-meth docutils literal"><span class="pre">remove()</span></tt></a>, but does not raise an exception if the
file does not exist.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.removedirs">
<tt class="descname">removedirs</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.removedirs" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.removedirs()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.removedirs_p">
<tt class="descname">removedirs_p</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.removedirs_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#pymel.util.common.path.removedirs" title="pymel.util.common.path.removedirs"><tt class="xref py py-meth docutils literal"><span class="pre">removedirs()</span></tt></a>, but does not raise an exception if the
directory is not empty or does not exist.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.rename">
<tt class="descname">rename</tt><big>(</big><em>new</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.rename" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.rename()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.renames">
<tt class="descname">renames</tt><big>(</big><em>new</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.renames" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.renames()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.rmdir">
<tt class="descname">rmdir</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.rmdir" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.rmdir()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.rmdir_p">
<tt class="descname">rmdir_p</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.rmdir_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#pymel.util.common.path.rmdir" title="pymel.util.common.path.rmdir"><tt class="xref py py-meth docutils literal"><span class="pre">rmdir()</span></tt></a>, but does not raise an exception if the
directory is not empty or does not exist.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.rmtree">
<tt class="descname">rmtree</tt><big>(</big><em>path</em>, <em>ignore_errors=False</em>, <em>onerror=None</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.rmtree" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively delete a directory tree.</p>
<p>If ignore_errors is set, errors are ignored; otherwise, if onerror
is set, it is called to handle the error with arguments (func,
path, exc_info) where func is os.listdir, os.remove, or os.rmdir;
path is the argument to that function that caused it to fail; and
exc_info is a tuple returned by sys.exc_info().  If ignore_errors
is false and onerror is None, an exception is raised.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.rmtree_p">
<tt class="descname">rmtree_p</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.rmtree_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#pymel.util.common.path.rmtree" title="pymel.util.common.path.rmtree"><tt class="xref py py-meth docutils literal"><span class="pre">rmtree()</span></tt></a>, but does not raise an exception if the
directory does not exist.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.samefile">
<tt class="descname">samefile</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.samefile" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.samefile()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.samepath">
<tt class="descname">samepath</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.samepath" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the other path represents the same path as this one.</p>
<p>This will account for symbolic links, absolute/relative paths,
case differences (if on a case-insensitive file system), and ‘..’
usage (so paths such as A//B, A/./B and A/foo/../B will all compare equal).</p>
<p>This will NOT account for hard links - use <a class="reference internal" href="#pymel.util.common.path.samefile" title="pymel.util.common.path.samefile"><tt class="xref py py-meth docutils literal"><span class="pre">samefile()</span></tt></a> for this, if
available on your os.</p>
<p>Essentially just compares the <tt class="xref py py-obj docutils literal"><span class="pre">self.canonicalpath()</span></tt> to <tt class="xref py py-obj docutils literal"><span class="pre">other.canonicalpath()</span></tt></p>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.size">
<tt class="descname">size</tt><a class="headerlink" href="#pymel.util.common.path.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the file, in bytes.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.getsize" title="pymel.util.common.path.getsize"><tt class="xref py py-meth docutils literal"><span class="pre">getsize()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.path.getsize()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.splitall">
<tt class="descname">splitall</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.splitall" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the path components in this path.</p>
<p>The first item in the list will be a path.  Its value will be
either <tt class="xref py py-data docutils literal"><span class="pre">os.curdir</span></tt>, <tt class="xref py py-data docutils literal"><span class="pre">os.pardir</span></tt>, empty, or the root
directory of this path (for example, <tt class="docutils literal"><span class="pre">'/'</span></tt> or <tt class="docutils literal"><span class="pre">'C:\\'</span></tt>).  The
other items in the list will be strings.</p>
<p><tt class="docutils literal"><span class="pre">path.path.joinpath(*result)</span></tt> will yield the original path.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.splitdrive">
<tt class="descname">splitdrive</tt><big>(</big><big>)</big> → Return ``(p.drive, &lt;the rest of p&gt;)``.<a class="headerlink" href="#pymel.util.common.path.splitdrive" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the drive specifier from this path.  If there is
no drive specifier, p.drive is empty, so the return value
is simply <tt class="docutils literal"><span class="pre">(path(''),</span> <span class="pre">p)</span></tt>.  This is always the case on Unix.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.splitdrive()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.splitext">
<tt class="descname">splitext</tt><big>(</big><big>)</big> → Return ``(p.stripext(), p.ext)``.<a class="headerlink" href="#pymel.util.common.path.splitext" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the filename extension from this path and return
the two parts.  Either part may be empty.</p>
<p>The extension is everything from <tt class="docutils literal"><span class="pre">'.'</span></tt> to the end of the
last path segment.  This has the property that if
<tt class="docutils literal"><span class="pre">(a,</span> <span class="pre">b)</span> <span class="pre">==</span> <span class="pre">p.splitext()</span></tt>, then <tt class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">==</span> <span class="pre">p</span></tt>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.splitext()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.splitpath">
<tt class="descname">splitpath</tt><big>(</big><big>)</big> → Return ``(p.parent, p.name)``.<a class="headerlink" href="#pymel.util.common.path.splitpath" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.parent" title="pymel.util.common.path.parent"><tt class="xref py py-attr docutils literal"><span class="pre">parent</span></tt></a>, <a class="reference internal" href="#pymel.util.common.path.name" title="pymel.util.common.path.name"><tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.path.split()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.splitunc">
<tt class="descname">splitunc</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.splitunc" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.path.splitunc()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.stat">
<tt class="descname">stat</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.stat" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a <tt class="docutils literal"><span class="pre">stat()</span></tt> system call on this path.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.lstat" title="pymel.util.common.path.lstat"><tt class="xref py py-meth docutils literal"><span class="pre">lstat()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">os.stat()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.statvfs">
<tt class="descname">statvfs</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.statvfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a <tt class="docutils literal"><span class="pre">statvfs()</span></tt> system call on this path.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.statvfs()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.stripext">
<tt class="descname">stripext</tt><big>(</big><big>)</big> → Remove one file extension from the path.<a class="headerlink" href="#pymel.util.common.path.stripext" title="Permalink to this definition">¶</a></dt>
<dd><p>For example, <tt class="docutils literal"><span class="pre">path('/home/guido/python.tar.gz').stripext()</span></tt>
returns <tt class="docutils literal"><span class="pre">path('/home/guido/python.tar')</span></tt>.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.symlink">
<tt class="descname">symlink</tt><big>(</big><em>newlink</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a symbolic link at <tt class="xref py py-obj docutils literal"><span class="pre">newlink</span></tt>, pointing here.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.symlink()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.text">
<tt class="descname">text</tt><big>(</big><em>encoding=None</em>, <em>errors='strict'</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.text" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file, read it in, return the content as a string.</p>
<p>This method uses <tt class="docutils literal"><span class="pre">'U'</span></tt> mode, so <tt class="docutils literal"><span class="pre">'\r\n'</span></tt> and <tt class="docutils literal"><span class="pre">'\r'</span></tt> are
automatically translated to <tt class="docutils literal"><span class="pre">'\n'</span></tt>.</p>
<dl class="docutils">
<dt>Optional arguments:</dt>
<dd><dl class="first last docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">encoding</span></tt> - The Unicode encoding (or character set) of</dt>
<dd>the file.  If present, the content of the file is
decoded and returned as a unicode object; otherwise
it is returned as an 8-bit str.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">errors</span></tt> - How to handle Unicode errors; see <tt class="xref py py-meth docutils literal"><span class="pre">str.decode()</span></tt></dt>
<dd>for the options.  Default is ‘strict’.</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pymel.util.common.path.lines" title="pymel.util.common.path.lines"><tt class="xref py py-meth docutils literal"><span class="pre">lines()</span></tt></a></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.touch">
<tt class="descname">touch</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.touch" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the access/modified times of this file to the current time.
Create the file if it does not exist.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.truepath">
<tt class="descname">truepath</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.truepath" title="Permalink to this definition">¶</a></dt>
<dd><p>The absolute, real, normalized path.</p>
<p>Shortcut for <tt class="xref py py-obj docutils literal"><span class="pre">abspath().realpath().normpath()</span></tt></p>
<p>Unlike canonicalpath, on case-sensitive filesystems, two different paths
may refer the same file, and so should only be used in cases where a
“normal” path from root is desired, but we wish to preserve case; in
situations where comparison is desired, <a class="reference internal" href="#pymel.util.common.path.canonicalpath" title="pymel.util.common.path.canonicalpath"><tt class="xref py py-meth docutils literal"><span class="pre">canonicalpath()</span></tt></a> (or
<a class="reference internal" href="#pymel.util.common.path.samepath" title="pymel.util.common.path.samepath"><tt class="xref py py-meth docutils literal"><span class="pre">samepath()</span></tt></a>) should be used.</p>
</dd></dl>
<dl class="attribute">
<dt id="pymel.util.common.path.uncshare">
<tt class="descname">uncshare</tt><a class="headerlink" href="#pymel.util.common.path.uncshare" title="Permalink to this definition">¶</a></dt>
<dd><p>The UNC mount point for this path.
This is empty for paths on local drives.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.unlink">
<tt class="descname">unlink</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.unlink" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.unlink()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.unlink_p">
<tt class="descname">unlink_p</tt><big>(</big><big>)</big><a class="headerlink" href="#pymel.util.common.path.unlink_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#pymel.util.common.path.unlink" title="pymel.util.common.path.unlink"><tt class="xref py py-meth docutils literal"><span class="pre">unlink()</span></tt></a>, but does not raise an exception if the
file does not exist.</p>
</dd></dl>
<dl class="classmethod">
<dt id="pymel.util.common.path.using_module">
<em class="property">classmethod </em><tt class="descname">using_module</tt><big>(</big><em>module</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.using_module" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.utime">
<tt class="descname">utime</tt><big>(</big><em>times</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.utime" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the access and modified times of this file.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">os.utime()</span></tt></p>
</div>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.walk">
<tt class="descname">walk</tt><big>(</big><big>)</big> → iterator over files and subdirs, recursively.<a class="headerlink" href="#pymel.util.common.path.walk" title="Permalink to this definition">¶</a></dt>
<dd><p>The iterator yields path objects naming each child item of
this directory and its descendants.  This requires that
D.isdir().</p>
<p>This performs a depth-first traversal of the directory tree.
Each directory is returned just before all its children.</p>
<p>The <tt class="xref py py-obj docutils literal"><span class="pre">errors=</span></tt> keyword argument controls behavior when an
error occurs.  The default is ‘strict’, which causes an
exception.  The other allowed values are ‘warn’, which
reports the error via <tt class="docutils literal"><span class="pre">warnings.warn()</span></tt>, and ‘ignore’.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.walkdirs">
<tt class="descname">walkdirs</tt><big>(</big><big>)</big> → iterator over subdirs, recursively.<a class="headerlink" href="#pymel.util.common.path.walkdirs" title="Permalink to this definition">¶</a></dt>
<dd><p>With the optional <tt class="xref py py-obj docutils literal"><span class="pre">pattern</span></tt> argument, this yields only
directories whose names match the given pattern.  For
example, <tt class="docutils literal"><span class="pre">mydir.walkdirs('*test')</span></tt> yields only directories
with names ending in ‘test’.</p>
<p>The <tt class="xref py py-obj docutils literal"><span class="pre">errors=</span></tt> keyword argument controls behavior when an
error occurs.  The default is ‘strict’, which causes an
exception.  The other allowed values are ‘warn’, which
reports the error via <tt class="docutils literal"><span class="pre">warnings.warn()</span></tt>, and ‘ignore’.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.walkfiles">
<tt class="descname">walkfiles</tt><big>(</big><big>)</big> → iterator over files in D, recursively.<a class="headerlink" href="#pymel.util.common.path.walkfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>The optional argument, <tt class="xref py py-obj docutils literal"><span class="pre">pattern</span></tt>, limits the results to files
with names that match the pattern.  For example,
<tt class="docutils literal"><span class="pre">mydir.walkfiles('*.tmp')</span></tt> yields only files with the .tmp
extension.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.write_bytes">
<tt class="descname">write_bytes</tt><big>(</big><em>bytes</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.write_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file and write the given bytes to it.</p>
<p>Default behavior is to overwrite any existing file.
Call <tt class="docutils literal"><span class="pre">p.write_bytes(bytes,</span> <span class="pre">append=True)</span></tt> to append instead.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.write_lines">
<tt class="descname">write_lines</tt><big>(</big><em>lines</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>linesep='\n'</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.write_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the given lines of text to this file.</p>
<p>By default this overwrites any existing file at this path.</p>
<p>This puts a platform-specific newline sequence on every line.
See <tt class="xref py py-obj docutils literal"><span class="pre">linesep</span></tt> below.</p>
<blockquote>
<div><p><a class="reference internal" href="#pymel.util.common.path.lines" title="pymel.util.common.path.lines"><tt class="xref py py-obj docutils literal"><span class="pre">lines</span></tt></a> - A list of strings.</p>
<dl class="docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">encoding</span></tt> - A Unicode encoding to use.  This applies only if</dt>
<dd><a class="reference internal" href="#pymel.util.common.path.lines" title="pymel.util.common.path.lines"><tt class="xref py py-obj docutils literal"><span class="pre">lines</span></tt></a> contains any Unicode strings.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">errors</span></tt> - How to handle errors in Unicode encoding.  This</dt>
<dd>also applies only to Unicode strings.</dd>
<dt>linesep - The desired line-ending.  This line-ending is</dt>
<dd>applied to every line.  If a line already has any
standard line ending (<tt class="docutils literal"><span class="pre">'\r'</span></tt>, <tt class="docutils literal"><span class="pre">'\n'</span></tt>, <tt class="docutils literal"><span class="pre">'\r\n'</span></tt>,
<tt class="docutils literal"><span class="pre">u'\x85'</span></tt>, <tt class="docutils literal"><span class="pre">u'\r\x85'</span></tt>, <tt class="docutils literal"><span class="pre">u'\u2028'</span></tt>), that will
be stripped off and this will be used instead.  The
default is os.linesep, which is platform-dependent
(<tt class="docutils literal"><span class="pre">'\r\n'</span></tt> on Windows, <tt class="docutils literal"><span class="pre">'\n'</span></tt> on Unix, etc.).
Specify <tt class="docutils literal"><span class="pre">None</span></tt> to write the lines as-is, like
<tt class="xref py py-meth docutils literal"><span class="pre">file.writelines()</span></tt>.</dd>
</dl>
</div></blockquote>
<p>Use the keyword argument append=True to append lines to the
file.  The default is to overwrite the file.  Warning:
When you use this with Unicode data, if the encoding of the
existing data in the file is different from the encoding
you specify with the encoding= parameter, the result is
mixed-encoding data, which can really confuse someone trying
to read the file later.</p>
</dd></dl>
<dl class="method">
<dt id="pymel.util.common.path.write_text">
<tt class="descname">write_text</tt><big>(</big><em>text</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>linesep='\n'</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#pymel.util.common.path.write_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the given text to this file.</p>
<p>The default behavior is to overwrite any existing file;
to append instead, use the <tt class="xref py py-obj docutils literal"><span class="pre">append=True</span></tt> keyword argument.</p>
<p>There are two differences between <a class="reference internal" href="#pymel.util.common.path.write_text" title="pymel.util.common.path.write_text"><tt class="xref py py-meth docutils literal"><span class="pre">write_text()</span></tt></a> and
<a class="reference internal" href="#pymel.util.common.path.write_bytes" title="pymel.util.common.path.write_bytes"><tt class="xref py py-meth docutils literal"><span class="pre">write_bytes()</span></tt></a>: newline handling and Unicode handling.
See below.</p>
<p>Parameters:</p>
<blockquote>
<div><p><a class="reference internal" href="#pymel.util.common.path.text" title="pymel.util.common.path.text"><tt class="xref py py-obj docutils literal"><span class="pre">text</span></tt></a> - str/unicode - The text to be written.</p>
<dl class="docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">encoding</span></tt> - str - The Unicode encoding that will be used.</dt>
<dd>This is ignored if ‘text’ isn’t a Unicode string.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">errors</span></tt> - str - How to handle Unicode encoding errors.</dt>
<dd>Default is ‘strict’.  See help(unicode.encode) for the
options.  This is ignored if ‘text’ isn’t a Unicode
string.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">linesep</span></tt> - keyword argument - str/unicode - The sequence of</dt>
<dd>characters to be used to mark end-of-line.  The default is
<tt class="xref py py-data docutils literal"><span class="pre">os.linesep</span></tt>.  You can also specify <tt class="docutils literal"><span class="pre">None</span></tt>; this means to
leave all newlines as they are in <a class="reference internal" href="#pymel.util.common.path.text" title="pymel.util.common.path.text"><tt class="xref py py-obj docutils literal"><span class="pre">text</span></tt></a>.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">append</span></tt> - keyword argument - bool - Specifies what to do if</dt>
<dd>the file already exists (<tt class="docutils literal"><span class="pre">True</span></tt>: append to the end of it;
<tt class="docutils literal"><span class="pre">False</span></tt>: overwrite it.)  The default is <tt class="docutils literal"><span class="pre">False</span></tt>.</dd>
</dl>
</div></blockquote>
<p>— Newline handling.</p>
<p>write_text() converts all standard end-of-line sequences
(<tt class="docutils literal"><span class="pre">'\n'</span></tt>, <tt class="docutils literal"><span class="pre">'\r'</span></tt>, and <tt class="docutils literal"><span class="pre">'\r\n'</span></tt>) to your platform’s default
end-of-line sequence (see <tt class="xref py py-data docutils literal"><span class="pre">os.linesep</span></tt>; on Windows, for example,
the end-of-line marker is <tt class="docutils literal"><span class="pre">'\r\n'</span></tt>).</p>
<p>If you don’t like your platform’s default, you can override it
using the <tt class="xref py py-obj docutils literal"><span class="pre">linesep=</span></tt> keyword argument.  If you specifically want
write_text() to preserve the newlines as-is, use <tt class="docutils literal"><span class="pre">linesep=None</span></tt>.</p>
<p>This applies to Unicode text the same as to 8-bit text, except
there are three additional standard Unicode end-of-line sequences:
<tt class="docutils literal"><span class="pre">u'\x85'</span></tt>, <tt class="docutils literal"><span class="pre">u'\r\x85'</span></tt>, and <tt class="docutils literal"><span class="pre">u'\u2028'</span></tt>.</p>
<p>(This is slightly different from when you open a file for
writing with <tt class="docutils literal"><span class="pre">fopen(filename,</span> <span class="pre">"w")</span></tt> in C or <tt class="docutils literal"><span class="pre">open(filename,</span> <span class="pre">'w')</span></tt>
in Python.)</p>
<p>— Unicode</p>
<p>If <a class="reference internal" href="#pymel.util.common.path.text" title="pymel.util.common.path.text"><tt class="xref py py-obj docutils literal"><span class="pre">text</span></tt></a> isn’t Unicode, then apart from newline handling, the
bytes are written verbatim to the file.  The <tt class="xref py py-obj docutils literal"><span class="pre">encoding</span></tt> and
<tt class="xref py py-obj docutils literal"><span class="pre">errors</span></tt> arguments are not used and must be omitted.</p>
<p>If <a class="reference internal" href="#pymel.util.common.path.text" title="pymel.util.common.path.text"><tt class="xref py py-obj docutils literal"><span class="pre">text</span></tt></a> is Unicode, it is first converted to bytes using the
specified ‘encoding’ (or the default encoding if <tt class="xref py py-obj docutils literal"><span class="pre">encoding</span></tt>
isn’t specified).  The <tt class="xref py py-obj docutils literal"><span class="pre">errors</span></tt> argument applies only to this
conversion.</p>
</dd></dl>
</dd></dl>
</div>
</div>
</div>
</div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<h4>Previous topic</h4>
<p class="topless"><a href="../../functions/pymel.util.common/pymel.util.common.unescape.html" title="previous chapter">pymel.util.common.unescape</a></p>
<h4>Next topic</h4>
<p class="topless"><a href="../../pymel.util.decoration.html" title="next chapter">pymel.util.decoration</a></p>
<h3><a href="../../../modules.html">Core Modules</a></h3>
<ul>
<li><a class="reference external" href="../../pymel.core.animation.html#module-pymel.core.animation"><tt class="xref">animation</tt></a></li>
<li><a class="reference external" href="../../pymel.core.effects.html#module-pymel.core.effects"><tt class="xref">effects</tt></a></li>
<li><a class="reference external" href="../../pymel.core.general.html#module-pymel.core.general"><tt class="xref">general</tt></a></li>
<li><a class="reference external" href="../../pymel.core.language.html#module-pymel.core.language"><tt class="xref">language</tt></a></li>
<li><a class="reference external" href="../../pymel.core.modeling.html#module-pymel.core.modeling"><tt class="xref">modeling</tt></a></li>
<li><a class="reference external" href="../../pymel.core.rendering.html#module-pymel.core.rendering"><tt class="xref">rendering</tt></a></li>
<li><a class="reference external" href="../../pymel.core.system.html#module-pymel.core.system"><tt class="xref">system</tt></a></li>
<li><a class="reference external" href="../../pymel.core.windows.html#module-pymel.core.windows"><tt class="xref">windows</tt></a></li>
</ul>
<h3><a href="../../../modules.html">Type Modules</a></h3>
<ul>
<li><a class="reference external" href="../../pymel.core.datatypes.html#module-pymel.core.datatypes"><tt class="xref">datatypes</tt></a></li>
<li><a class="reference external" href="../../pymel.core.nodetypes.html#module-pymel.core.nodetypes"><tt class="xref">nodetypes</tt></a></li>
<li><a class="reference external" href="../../pymel.core.uitypes.html#module-pymel.core.uitypes"><tt class="xref">uitypes</tt></a></li>
</ul>
<h3><a href="../../../modules.html">Other Modules</a></h3>
<ul>
<li><a class="reference external" href="../../pymel.api.plugins.html#module-pymel.api.plugins"><tt class="xref">plugins</tt></a></li>
<li><a class="reference external" href="../../pymel.mayautils.html#module-pymel.mayautils"><tt class="xref">mayautils</tt></a></li>
<li><a class="reference external" href="../../pymel.util.html#module-pymel.util"><tt class="xref">util</tt></a></li>
<li><a class="reference external" href="../../pymel.versions.html#module-pymel.versions"><tt class="xref">versions</tt></a>
</li><li><a class="reference external" href="../../pymel.tools.html#module-pymel.tools"><tt class="xref">tools</tt></a></li>
</ul>
<!--
<ul>   
<li><a class="reference external" href="../../pymel.core.animation.html.html#module-pymel.core.animation"><tt class="xref">animation</tt></a></li>
<li><a class="reference external" href="../../pymel.core.datatypes.html.html#module-pymel.core.datatypes"><tt class="xref">datatypes</tt></a></li>
<li><a class="reference external" href="../../pymel.core.effects.html.html#module-pymel.core.effects"><tt class="xref">effects</tt></a></li>
<li><a class="reference external" href="../../pymel.core.general.html.html#module-pymel.core.general"><tt class="xref">general</tt></a></li>
<li><a class="reference external" href="../../pymel.core.language.html.html#module-pymel.core.language"><tt class="xref">language</tt></a></li>
<li><a class="reference external" href="../../pymel.core.modeling.html.html#module-pymel.core.modeling"><tt class="xref">modeling</tt></a></li>
<li><a class="reference external" href="../../pymel.core.nodetypes.html.html#module-pymel.core.nodetypes"><tt class="xref">nodetypes</tt></a></li>
<li><a class="reference external" href="../../pymel.core.rendering.html.html#module-pymel.core.rendering"><tt class="xref">rendering</tt></a></li>
<li><a class="reference external" href="../../pymel.core.system.html.html#module-pymel.core.system"><tt class="xref">system</tt></a></li>
<li><a class="reference external" href="../../pymel.core.windows.html.html#module-pymel.core.windows"><tt class="xref">windows</tt></a></li>
<li><a class="reference external" href="../../pymel.util.html.html#module-pymel.util"><tt class="xref">pymel.util</tt></a></li>

</ul>
-->
<h3>This Page</h3>
<ul class="this-page-menu">
<li><a href="../../../_sources/generated/classes/pymel.util.common/pymel.util.common.path.txt" rel="nofollow">Show Source</a></li>
</ul>
<div id="searchbox" style="display: none">
<h3>Quick search</h3>
<form action="http://help.autodesk.com/cloudhelp/2016/ENU/Maya-Tech-Docs/PyMel/search.html" class="search" method="get"></form>
<input name="q" type="text"/>
<input type="submit" value="Go"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
<p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
</div>
<div class="clearer"></div>
</div>
<div class="related">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a href="../../../genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="../../../py-modindex.html" title="Python Module Index">modules</a> |</li>
<li class="right">
<a href="../../pymel.util.decoration.html" title="pymel.util.decoration">next</a> |</li>
<li class="right">
<a href="../../functions/pymel.util.common/pymel.util.common.unescape.html" title="pymel.util.common.unescape">previous</a> |</li>
<li><a href="../../../index-2.html">PyMEL 1.0.7 documentation</a> »</li>
<li><a href="../../pymel.util.common.html">pymel.util.common</a> »</li>
</ul>
</div>
<div class="footer">
        © Copyright 2009, Chad Dombrova.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
<!-- Mirrored from help.autodesk.com/cloudhelp/2016/ENU/Maya-Tech-Docs/PyMel/generated/classes/pymel.util.common/pymel.util.common.path.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 05:16:32 GMT -->
</body></html>